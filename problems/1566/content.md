## 描述

基本思想： 假设WN=(V,{E})是一个含有n个顶点的连通网，则按照克鲁斯卡尔算法构造最小生成树的过程为： （1）先构造一个只含n个顶点，而边集为空的子图，若将该子图中各个顶点看成是各棵树上的根结点，则它是一个含有n棵树的一个森林。 （2）之后，从网的边集E中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图，也就是说，将这两个顶点分别所在的两棵树合成一棵树；反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之。 依次类推，直至森林中只有一棵树，也即子图中含有n-1条边为止。 读入一个带权连通图。（1、连通的无向图；2、强连通的有向图） <img border="0" src="http://127.0.0.1:80/JudgeOnline/images/P1565_1.jpg" /> Procedure kruskal(V,E); begin sort(E,1,m);//将边按照权值排序 for t:=1 to m do begin if getfather(edge[t].u)<>getfather(edge[t].v) then begin //利用并查集判断两个顶点是否在同一集合内 tot:=tot+edge[t].data;//计算权值和 union(edge[t].u,edge[t].v);//合并顶点 inc(k);//合并次数 end; end; if k=n-1 then 形成了一棵最小生成树 else 不存在这样的最小生成树； end;

## 输入格式

第一直读入两个整数，结点数n；边数m； 接下来读入m行，每行均为3个整数：（a，b），w表示无向图；或 <a，b>，w表示有向图</a，b>

## 输出格式

<p> 输出为一个整数：17 </p> <p> 若无法连通，则输出：no </p> <p> 不需要输出各个结点在无向图的连接情况。 </p>

## 输入样例

```plaintext
6 10 (1,2) 7 (1,3) 6 (1,4) 2 (2,4) 4 (2,5) 4 (3,4) 5 (3,6) 3 (4,5) 5 (4,6) 4 (5,6) 6
```

## 输出样例

```plaintext
17 {（不需要输出）例如： 1-->4 3-->6 2-->4 2-->5 4-->6}
```

Hint

<br />



 

