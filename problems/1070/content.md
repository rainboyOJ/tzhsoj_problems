## 描述

Flood Fill 种子染色法 译 by Lucky Crazy & Felicia Crazy （Flood Fill 按原意应翻译成“水流式填充法”（如果我没译错），有些中文书籍上将它称作“种子染色法”，然而大部分的书籍（包括中文书籍）都直接引用其英文原名：Flood Fill。介于此，下文所有涉及到Flood Fill的都直接引用英文 ——译者） 样例： 相连的农场 Farmer John的农场被一次意外事故破坏了，有一些农场与其他的农场之间有道路相连，而有些道路却已被破坏。这使得Farmer John 无法了解到从一个农场能否到达另一个农场。你的任务就是帮助Farmer John来了解哪些农场是连通的。 给出： 上题实际上就是要求寻找一张无向图的所有极大连通子图。 给出一张未知连通性的图，如下图： <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood1.gif > 可知，该图的极大连通子图是：{1,4,8}， {2,5,6,7,9} 和 {3}。 算法: Flood Fill Flood Fill 可以用深度优先搜索，广度优先搜索或广度优先扫描来实现。他的实现方式是寻找到一个未被标记的结点对它标记后扩展，将所有由它扩展出的结点标上与它相同的标号，然后再找另一个未被标号的 结点重复该过程。这样，标号相同的结点就属于同一个连通子图。 深搜：取一个结点，对其标记，然后标记它所有的邻结点。对它的每一个邻结点这么一直递归下去完成搜索。 广搜：与深搜不同的是，广搜把结点加入队列中。 广度扫描（不常见）：每个结点有两个值，一个用来记录它属于哪个连通子图（c），一个用来标记是否已经访问（v）。算法对每一个未访问而在某个连通子图当中的结点扫描，将其标记访问，然后把它的邻结点的（c）值改为当前结点的（c）值。 深搜最容易写，但它需要一个栈。搜索显式图没问题，而对于隐式图，栈可能就存不下了。 广搜稍微好一点，不过也存在问题。搜索大的图它的队列有可能存不下。深搜和广搜时间复杂度均为O(N+M)。其中，N为结点数，M为边数。 广度扫描需要的额外空间很少，或者可以说根本不要额外空间，但是它很慢。时间复杂度是O(N^2+M)。 （实际应用中，我们一般写的是DFS，因为快。空间不是问题，DFS可改用非递归的栈操作完成。但为了尊重原文，我们还是译出了广度扫描的全过程。——译者） 广度扫描的伪代码 代码中用了一个小技巧，因此无须额外空间。结点若未访问，将其归入连通子图（-2），就是代码里的component -2。这样无须额外空间来记录结点是否访问，请读者用心体会。 <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood2.gif > 算法的时间复杂度是 O(N 2)，每个结点访问一次，每条边经过两次。 实例 考虑刚才的那张图： <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood3.gif > 开始时，所有的结点都没有访问。（下例中未访问被表示为 -2) 首先从结点1开始，结点1未访问，那么先处理结点1，将它归入连通子图1。 <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood4.gif > 标记完成后，对它进行第一步的扩展，由结点4和结点8与结点1连通，故它们被扩展出来。 <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood5.gif > 之后，先处理结点4，将它与结点1归入相同的连通子图。现在它没有可扩展的结点了（结点1已被扩展过） 　 <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood6.gif > 接着处理结点8。结果与结点4一样。 <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood7.gif > 现在，所有与结点1连通的结点都已扩展，标号为1的连通子图产生了。那么我们将跳出扩展步骤，寻找下一个连通子图，标号为2。 与上一步相同的顺序，找到结点2。 <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood8.gif > 扩展结点2，结点7与结点9出现。 <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood9.gif > 下一步，扩展结点7，结点5出现。 <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood10.gif > 然后是结点9。 <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood11.gif > 扩展结点5。结点6出现。 <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood12.gif > 很遗憾，结点6没有可供扩展的结点。至此连通子图2产生。 　 <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood13.gif > 之后寻找连通子图3，至此，仅有结点3未被扩展。 　 <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood14.gif > 结点3没有可供扩展的结点，这样，结点3就构成了仅有一个结点的连通子图3。 　 <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood15.gif > 结点3处理结束后，整个图的所有9个结点就都被归入相应的3个连通子图。Flood Fill 结束。 问题提示 这类问题一般很清晰，求解关于“连通”的问题会用到 Flood Fill。它也很经常用作某些算法的预处理。 扩展与延伸 有向图的连通性比较复杂。 同样的填充算法可以找出从一个结点能够到达的所有结点。每一层递归时，若一个结点未访问，就将其标记为已访问（表示他可以从源结点到达)，然后对它所有能到达且为访问的结点进行下一层递归。 若要求出可以到达某个结点的所有结点，你可以对后向弧做相同的操作。 例题 控制公司 [有删节, IOI 93] 已知一个带权有向图，权值在0-100之间。 如果满足下列条件，那么结点A“拥有”结点B： A = B 从A到B有一条权值大于50的有向弧。 存在一系列结点 C 1 到 C k 满足 A 拥有 C 1 到 C k, 每个节点都有一条弧到B，记作x 1 ，x 2 ...x k，并且 x 1 + x 2 + ... + x k > 50。 找出所有的（A，B）对，满足A拥有B。 分析：这题可以用上面提到的“给出一个源，在有向图中找出它能够到达的结点”算法的改进版解决。要计算A拥有的结点，要对每个结点计算其“控股百分比”。把它们全部设为0。现在，在递归的每一步中，将其标记为属于A并把它所有出弧的权加到“控股百分比”中。对于每个“控股百分比”超过50的结点，进行同样的操作（递归）。 　 街道赛跑 [IOI 95] 已知一个有向图，一个起点和一个终点。 找出所有的p，使得从起点到终点的任何路径都必须经过p。 分析：最简单的算法是枚举p，然后把p删除，看看是否存在从起点到终点的通路。时间复杂度为O(N (M + N))。题目的数据范围是 M <= 100, N <= 50，不会超时。 牛路 [1999 USACO 国家锦标赛, 有删节] 连通图的直径定义为图中任意两点间距离的最大值，两点间距离定义为最短路的长。 已知平面上一个点集，和这些点之间的连通关系，找出不在同一个连通子图中的两个点，使得连接这两个点后产生的新图有最小的直径。 分析：找出原图的所有连通子图，然后枚举不在同一个连通子图内的每个点对，将其连接，然后找出最小直径。 笨蛋建筑公司 Farmer John 计划建造一个新谷仓。不幸的是，建筑公司把他的建造计划和其他人的建造计划混淆了。Farmer John 要求谷仓只有一个房间，但是建筑公司为他建好的是有许多房间的谷仓。已知一个谷仓平面图，告诉Farmer John 它一共有多少个房间。 分析：随便找一个格子，遍历所有与它连通的格子，得到一个房间。然后再找一个未访问的格子，做同样的工作，直到所有的格子均已访问。虽然题目给你的不是直接的图，但你也可以很容易地对其进行Flood Fill。 

## 输入格式

Flood Fill Sample Problem: Connected Fields Farmer John's fields are broken into fields, with paths between some of them. Unfortunately, some fields are not reachable from other fields via the paths. Define a superfield is a collection of fields that are all reachable from each other. Calculate the number of superfields. The Abstraction Given: a undirected graph The component of a graph is a maximal-sized (though not necessarily maximum) subgraph which is connected. Calculate the component of the graph. <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood1.gif > This graph has three components: {1,4,8}, {2,5,6,7,9}, and {3}. The Algorithm: Flood Fill Flood fill can be performed three basic ways: depth-first, breadth-first, and breadth-first scanning. The basic idea is to find some node which has not been assigned to a component and to calculate the component which contains. The question is how to calculate the component. In the depth-first formulation, the algorithm looks at each step through all of the neighbors of the current node, and, for those that have not been assigned to a component yet, assigns them to this component and recurses on them. In the breadth-first formulation, instead of recursing on the newly assigned nodes, they are added to a queue. In the breadth-first scanning formulation, every node has two values: component and visited. When calculating the component, the algorithm goes through all of the nodes that have been assigned to that component but not visited yet, and assigns their neighbors to the current component. The depth-first formulation is the easiest to code and debug, but can require a stack as big as the original graph. For explicit graphs, this is not so bad, but for implicit graphs, such as the problem presented has, the numbers of nodes can be very large. The breadth-formulation does a little better, as the queue is much more efficient than the run-time stack is, but can still run into the same problem. Both the depth-first and breadth-first formulations run in N + M time, where N is the number of vertices and M is the number of edges. The breadth-first scanning formulation, however, requires very little extra space. In fact, being a little tricky, it requires no extra space. However, it is slower, requiring up to N*N + M time, where N is the number of vertices in the graph. Pseudocode for Breadth-First Scanning This code uses a trick to not use extra space, marking nodes to be visited as in component -2 and actually assigning them to the current component when they are actually visited. <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood2.gif > Running time of this algorithm is O(N 2), where N is the numbers of nodes. Every edge is traversed twice (once for each end-point), and each node is only marked once. Execution Example Consider the graph from above. <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood3.gif > The algorithm starts with all nodes assigned to no component. Going through the nodes in order first node not assigned to any component yet is vertex 1. Start a new component (component 1) for that node, and set the component of node 1 to -2 (any nodes not shown are unassigned). <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood42.gif > Now, in the flood_fill code, the first time through the do loop, it finds the node 1 is assigned to component -2. Thus, it reassigns it to component 1, signifying that it has been visited, and then assigns its neighbors (node 4) to component -2. <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood52.gif > As the loop through all the nodes continues, it finds that node 4 is also assigned to component -2, and processes it appropriately as well. <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood62.gif > Node 8 is the next to be processed. <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood72.gif > Now, the for loop continues, and finds no more nodes that have not been assigned yet. Since the until clause is not satisfied ( num_visited = 3), it tries again. This time, no nodes are found, so the function exits and component 1 is complete. The search for unassigned nodes continues, finding node 2. A new component (component 2) is allocated, node 2 is marked as in component -2, and flood_fill is called. <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood82.gif > Node 2 is found as marked in component -2, and is processed. <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood92.gif > Next, node 7 is processed. <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood102.gif > Then node 9 is processed. <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood112.gif > The terminating condition does not hold ( num_visited = 3), so the search through for nodes assigned to component -2 starts again. Node 5 is the first one found. <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood122.gif > Node 6 is the next node found to be in component -2. <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood132.gif > No more nodes are found assigned to component -2, but the terminating condition does not hold, so one more pass through the nodes is performed, finding no nodes assigned to component -2. Thus, the search for unassigned nodes continue from node 2, finding node 3 unassigned. <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood142.gif > Node 3 is processed. <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood152.gif > From here, the algorithm eventually terminates, as there are no more nodes assigned to component -2 and no unassigned nodes. The three components of the graph have been determined, along with the component to which each node belongs. Problem Cues Generally, these types of problem are fairly clear. If it asks for sets of "connected" things, it's probably asking for components, in which case flood fill works very well. Often, this is a step in solving the complete problem. Extensions The notion of ``components'' becomes muddied when you go to directed graphs. However, the same flooding idea can be used to determine the points which are reachable from any given point even in a directed graph. At each recursive step, if the point isn't marked already, mark the point as reachable and recurse on all of its neighbors. Note that to determine which points can reach a given point in a directed graph can be solved the same, by looking at every arc backwards. Sample Problems Company Ownership [abridged, IOI 93] Given: A weighted directed graph, with weights between 0 and 100. Some vertex A ``owns'' another vertex B if: <img border=0 src=http://10.10.10.3:8080/JudgeOnline/images/p1070/flood162.gif > Find all (a,b) pairs such that a owns b. Analysis: This can be solved via an adaptation of the calculating the vertices reachable from a vertex in a directed graph. To calculate which vertices vertex A owns, keep track of the ``ownership percentage'' for each node. Initialize them all to zero. Now, at each recursive step, mark the node as owned by vertex A and add the weight of all outgoing arcs to the ``ownership percentages.'' For all percentages that go above 50, recurse into those vertices. Street Race [IOI 95] Given: a directed graph, and a start point and an end point. Find all points p that any path from the start point to the end must travel through p. Analysis: The easiest algorithm is to remove each point in turn, and check to see if the end point is reachable from the start point. This runs in O(N (M + N)) time. Since the original problem stated that M <= 100, and N <= 50, this will run in time easily. Cow Tours [1999 USACO National Championship, abridged] The diameter of a connected graph is defined as the maximum distance between any two nodes of the graph, where the distance between two nodes is defined as the length of the shortest path. Given a set of points in the plane, and the connections between those points, find the two points which are currently not in the same component, such that the diameter of the resulting component is minimized. Analysis: Find the components of the original graph, using the method described above. Then, for each pair of points not in the same component, try placing a connection between them. Find the pair that minimizes the diameter. Connected Fields Farmer John contracted out the building of a new barn. Unfortunately, the builder mixed up the plans of Farmer John's barn with another set of plans. Farmer John's plans called for a barn that only had one room, but the building he got might have many rooms. Given a grid of the layout of the barn, tell Farmer John how many rooms it has. Analysis: The graph here is on the non-wall grid locations, with edge between adjacent non-wall locations, although the graph should be stored as the grid, and not transformed into some other form, as the grid is so compact and easy to work with. 

## 输出格式

 

## 输入样例

```plaintext
第一行两个整数n、m（n表示无向图中结点个数，m表示图中边的数量）； 接下来共计m行，表示有m条边，每一条边对就的一对结点。 如： 10 9 1 4 1 8 2 7 2 9 3 10 5 6 5 7 5 9 7 9 
```

## 输出样例

```plaintext
输出为行，一个整数k（表示该无向图中有多少个极大连通子图） 3 
```



 

## 来源

USACO教程：Flood Fill种子染色法

