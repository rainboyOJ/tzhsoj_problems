## 描述

Advanced algorithms and difficult drills(高级算法与困难的习题) 目录 [隐藏] 1 什么是最优化？ 2 一个问题：链 3 优化的基础 4 链问题的优化 什么是最优化？ 让你的工作代码更快 注意你的工作。在你的程序工作之前，不要试图让它变得更快，因为调试查错可能将更为复杂。在为了优化（而不是调试查错）而对程序作出任何更改之前，给你的代码做一下备份。当你作出了3种深层次的优化之后，发现第一次的优化破坏了程序的正确性，而此时你又没有任何备份可以恢复之前的正确程序，没有再比这更为痛苦的事了。 这块内容将注意几种能加速程序而不更改算法的方法。当然如果有更快的算法，则你的思考方向就应该是思考那种算法，而不是让一种本来就很慢的算法快那么一小点，这就像在猪身上使用香水一样。（USACO这个比喻有点......） 尤其值得注意的是，本模块内容仅将讨论使递归下降程序变得更快的方法，尝试避免搜索整棵树。这种方法通常被归为搜索的剪枝。 一个问题：链 这是一个在编译器中的现实问题，虽然在那个世界中只有乘法是可用的。 假设一个程序需要精确地得到x^n的值，而标准操作只有乘和除（没有 log/exp）。这些操作最少需要多少次？按次序输出为得到x^n所需要计算的x的幂值。 为了说明这个问题，以下给出的计算过程将仅表现指数，乘法将被表示为加法（两个指数的和），除法将被表示为减法（两个指数的差）。在合法的链中，每个指数都将是两个已得出的指数的和或差。所以计算x^8的序列将表示为：1 2 4 8；计算x^15的序列可以表示为：1 2 4 8 16 15 Test Set #1 考虑计算集合[1..50]内的数据。所有时间将在233MHz的Pentium II处理器上得到。 一个基本的算法 从1开始，进行深度优先搜索。 出现了什么问题？ 这个程序将永远不会终止。 所以需要改变算法以减少生成比答案更长的数列的次数。假设最长链的长度为32，为实现例子所需的运行时间达到了4658.34秒。 优化的基础 更早地剪枝，更频繁地剪枝 思考：在一棵输出2的搜索树中，避免搜索出超过4个节点。 两个能使搜索更快的基本思想： 不要做任何愚蠢的事 不要把事情做两遍 问题在于如何找到进行了两遍的事,什么是愚蠢的事。这里所有的优化操作都建立在计算正确的前提下，你要保证你的程序是正确的。 链问题的优化 Observation #1 有一种简单的方法可以先确定出一个数，或者纯粹是先得一个搜索的最大值。计算n的二进制表示形式，首先不断生成2的幂值，再将这些生成的数相加得到n。 举例说：n=43，则它的二进制形式为101011。因此，首先的到的数列为：1 2(10) 4(100) 8(1000) 16(10000) 32(100000)，所以计算1+2=3(11)，3+8=11(1011)，11+32=43(101011)。故输出数列：1 2 4 8 16 32 3 11 43。至少可以先得到一个“最优解”。 而这个程序的运行时间为4609.81秒。 评价：这只是勉强可以算是优化。虽然这避免了很多不必要的计算，但在一棵如此巨大的搜索树中确实不能起到太大作用。 Observation #2 出现负数显然是愚蠢的，不要让它们出现在数列中。（证明过程略...） 现在新的运行时间为387.34秒。 出现0甚至更愚蠢。（证明过程略...） 新的运行时间：43.24秒。 评价：两个简单的操作减少了100倍数量级地运算时间，并且它们的代码非常容易写，这非常好地体现了优秀的优化。 Observation #3 在一步操作中，可能生成的最大整数是当前已生成的序列中最大数的2倍，所以，如果当前最大值乘以 2^到达当前最优解的剩余操作数 小于目标，那么，停止。 运行时间：0.15秒。 增加数据规模 目前程序很快，我们应该增加数据规模了。新的数据中幂不大于300，运行时间是93.21秒。 注意4 为什么不使用迭代加深搜索呢？这个搜索的分支系数很大，随着深度的增加结点数成指数级增长，所以进行迭代加深搜索所进行的多余运算相对而言是很少的。 运行时间: 93.05秒。 评价：既然这样,从数据看这是一个不强的优化(慢慢会好起来)。它使程序代码产生了很大的改变，出错的机会增加了，还没有带来任何好处。这令我们有点惊讶，它一向有很大作用。 注意5 最近的操作必须使用倒数第二个数。如果不用，生成它干什么? (现在就呈现出可变下界深度优先搜索算法)。 运行时间: 7.47 秒 。 注意6 不要复制已有的数。 运行时间:：3.40 秒 检查 这样, 除了可变下界深度优先搜索以外，只有“Don't Do Anything Stupid”这一原则被体现了，执行时间减少了约842,510倍。这是好的，但也许可以再提高。 增加数据规模 新的数据中幂不大于500，运行时间是206.71秒。 注意7 如果一个数列的前缀没有得到解，在后面加什么数也没有用。例如，如果1 2 4 8 7得不到解，就不用尝试1 2 4 8 16 7了。 运行时间： 53.70 秒 注意8 如果选择了i,数列中最大的数是j,而且i+j小于下一个需要的数,那就不要选择i。 运行时间: 44.52 秒。 注意9 如果一个数列生成 x (x不是目标)用了j项，而且存在另外一个数列用了少于j项，我们应该用这个短的数列把它替换掉，获得一个“更好的”数列，这是最佳的。 错误! 第一个反例: 10,127.用这种方法得到的解是17项，但是存在一个16项的方法。 这就是优化的风险：有时候，会得到错误结论。确保你不会掉入陷阱. 总结 8个优化使运行时间缩小400万倍。可以使不大于500的数据在44.52秒内出解。有的程序可以在640k内存限制的情况下1.91秒内出解(无限制时0.85秒)。看看你的程序有多快。 来自“http://www.nocow.cn/index.php?title=Translate:USACO/Optimization&oldid=30735” 

## 输入格式

 

## 输出格式

 

## 输入样例

```plaintext
 
```

## 输出样例

```plaintext
 
```



 



 

